#! /usr/bin/env python3

import os
import re
import json
import time
import pickle
import random
import argparse
import datetime
import numpy as np

import robot

from utils import print_header, plot_population_stats, store_history
from algorithms import (vie,
                        mu_plus_lambda as mu_p_l,
                        map_elites)
from visualization import fitness_evolution, map_like, visualize_trajectory

from deap import base, creator, tools

# library for parallel execution
import multiprocessing

# DEAP creator utils - they need to be global in order to be used with multiprocessing
creator.create('FitnessMax', base.Fitness, weights=(1.0,))
creator.create('Robot', robot.Robot, fitness=creator.FitnessMax)


def main(config, tbox, use_checkpoint=False, fresh_start=False):
    print_header(config)

    # ====== SIMULATION CONFIGURATION ====== #
    max_num_sims = config.get('max_num_sims', 38400)

    # prepare output folders
    results_dir = config['result_dir']
    cp_folder = os.path.join(results_dir, 'checkpoints')
    # Note: the result_dir must be a proper path where 
    # to store the files, otherwise the execution will fail
    os.makedirs(results_dir, exist_ok=True)
    os.makedirs(cp_folder, exist_ok=True)

    # save selected configuration within the result folders
    # this simplify the reproduction of the result with the simulation
    config['timestamp'] = datetime.datetime.now().replace(microsecond=0).isoformat()
    with open(os.path.join(results_dir, 'settings.json'), 'w') as conf_file_fr:
        json.dump(config, conf_file_fr)
    # ====================================== #

    history_file = config.get('history_file', None)
    if fresh_start and os.path.exists(history_file):
        os.remove(history_file)

    alg = config.get('algorithm')
    seeds = config.get('seeds', [])
    checkpoint_files = {int(f.split('_')[-1][0]): os.path.join(cp_folder, f)
                        for f in os.listdir(cp_folder)
                        if re.match('checkpoint_[0-9]+_[0-9]\.pkl', f)}

    for i in range(config.get('num_sim', 3)):
        start_time = time.time()
        print('\n# {} SIMULATION {} {} #\n'.format('='*18, i, '='*18))

        # select the seed for experiments repeatability
        seed = seeds[i] if i < len(seeds) else random.randint(0, 1000000)

        pop = None
        # check-pointing reloading mechanism
        alg_data = None
        if use_checkpoint and i in checkpoint_files\
                and os.path.exists(checkpoint_files[i]):
            with open(checkpoint_files[i], 'rb') as cpf:
                cp_data = pickle.load(cpf)

                # extract data from the checkpoint according
                # to which algorithm generated it
                if alg['name'] == 'mu+lambda':
                    pop = cp_data['population']
                    random.setstate(cp_data['rnd_state'])
                    alg_data = {
                        'last_num_sims': cp_data['num_sims'],
                        'num_gen': cp_data['num_gen']
                    }
                elif alg['name'] == 'vie':
                    pop = cp_data['population']
                    random.setstate(cp_data['rnd_state'])
                    alg_data = {
                        'last_num_sims': cp_data['num_sims'],
                        'num_gen': cp_data['num_gen'],
                        'init_pop_size': cp_data['init_pop_size'],
                        'current_boundary': cp_data['current_boundary'],
                        'family_ids': cp_data['family_ids'],
                        'prob': cp_data['prob']
                    }
                elif alg['name'] == 'map-elites':
                    alg_data = {
                        'last_num_sims': cp_data['num_sims'],
                        'num_gen': cp_data['num_gen'],
                        'archive': cp_data['archive'],
                        'curiosity': cp_data['curiosity'],
                    }
                    random.setstate(cp_data['rnd_state'])
                else:
                    random.seed(seed)
                    np.random.seed(seed)
        else:
            random.seed(seed)
            np.random.seed(seed)
        # ======================================== #

        # ========= Evolution file ========= #
        # here are stored every single individual generated by the EA throughout the evolutionary process
        evo_filename = os.path.join(results_dir, 'evo_{}_sim_{}.json'.format(seed, i))
        if use_checkpoint and os.path.exists(evo_filename):
            # overwrite closing bracket to allow continuing writing on ti
            with open(evo_filename, 'rb+') as ef:
                ef.seek(-1, os.SEEK_END)
                ef.truncate()
            evo_file = open(evo_filename, 'a')
        else:
            evo_file = open(evo_filename, 'w')
            # open the json list of generations
            evo_file.write('[')
        # ================================== #

        best = None
        archive = None

        # execute specific EA depending on the configuration
        TIME_NO_UPDATE = alg.get('time_no_update', 10000)
        if alg['name'] == 'mu+lambda':
            MU = alg.get('mu', 48)
            LAMBDA = alg.get('lambda', 48)
            CXPB = alg.get('cx_prob', 0.0)
            MUTPB = alg.get('mut_prob', 1.0)

            if pop is None:
                pop = tbox.population(MU)
            [pop, best, history, history_local] =\
                mu_p_l.run(pop, tbox, evo_file, MU, LAMBDA,
                           CXPB, MUTPB, max_num_sims,
                           verbose=config.get('verbose', True),
                           cp_freq=settings.get('checkpoint_freq', 10),
                           cp_folder=cp_folder,
                           history_file=history_file,
                           sim_id=i, seed=seed, alg_data=alg_data,
                           time_no_update=TIME_NO_UPDATE)

        elif alg['name'] == 'vie':
            pop_size = alg.get('pop_size', 48)
            num_mutants = alg.get('num_mutants', 48)
            conv_rate = alg.get('conv_rate', 0.1)

            if pop is None:
                pop = tbox.population(pop_size)
            [pop, best, history, history_local] =\
                vie.run(pop, tbox, evo_file, max_num_sims,
                        conv_rate, num_mutants,
                        verbose=config.get('verbose', True),
                        cp_freq=settings.get('checkpoint_freq', 10),
                        cp_folder=cp_folder,
                        history_file=history_file,
                        sim_id=i, seed=seed, alg_data=alg_data,
                        boundary_dist=0.1, time_no_update=TIME_NO_UPDATE)

        elif alg['name'] == 'map-elites':
            num_init_sols = alg.get('num_init_sols', 1200)
            batch_size = alg.get('batch_size', 24)

            if pop is None:
                init_sols = tbox.population(num_init_sols)

            # manage the 2D vs 3D case
            if config['robot'].get('per_module_stiffness', False):
                map_dims = (config['robot']['max_num_modules'] - robot.MIN_NUM_MODULES + 1,
                            len(config['robot']['modules_conf']['stiff_table']),
                            len(config['robot']['modules_conf']['stiff_table']))
            else:
                map_dims = (config['robot']['max_num_modules'] - robot.MIN_NUM_MODULES + 1,
                            len(config['robot']['modules_conf']['stiff_table']))

            [archive, history] = map_elites.run(init_sols, tbox, evo_file, max_num_sims,
                                                map_dims, batch_size,
                                                verbose=config.get('verbose', True),
                                                cp_folder=cp_folder,
                                                cp_freq=settings.get('checkpoint_freq', 5),
                                                arch_folder=results_dir,
                                                history_file=history_file,
                                                use_curiosity=settings.get('use_curiosity', False),
                                                seed=seed, sim_id=i, alg_data=alg_data,
                                                time_no_update=TIME_NO_UPDATE)
        else:
            raise Exception('{} algorithm is not implemented!'.format(config.get('algorithm')))

        # close the json evolution list
        evo_file.write(']')
        evo_file.close()

        # created output folders
        best_folder = os.path.join(results_dir, 'best')
        trajectories_dir = os.path.join(best_folder, 'trajectories')

        # creates all the folders till the leaf one
        os.makedirs(trajectories_dir, exist_ok=True)

        # keep track of the best results
        print('Saving results...')
        if best is not None and len(best) > 0:
            for k, rob in enumerate(best):
                print(f'\rRobot: {k+1}/{len(best)}', end='')
                basename = 'robot_{}_{}_seed_{}_sim_{}'.format(k, rob.features_desc_str(), seed, i)
                rob.write_input(os.path.join(best_folder, basename + '.txt'))
                rob.generate_trajectory(os.path.join(trajectories_dir, basename + '.csv'))

            # store the population obtained from the simulation
            pop_filename = 'pop_{}_sim_{}.pkl'.format(seed, i)
            with open(os.path.join(results_dir, pop_filename), 'wb') as pop_file:
                pickle.dump(pop, pop_file)

            # store local history to create a MAP from it
            history_local_fname = 'history_{}_sim_{}.csv'.format(seed, i)
            store_history(history_local, os.path.join(results_dir, history_local_fname))

            # plot last population distribution (fitness, num modules and stiffness)
            plot_population_stats(pop, results_dir, seed, i)

            # plot MAP-Elites like archive for non-illumination algorithms
            map_like.plot(results_dir, history_local_fname, seed=seed, sim_id=i,
                          is_3d=config['robot'].get('per_module_stiffness', False))

        elif archive is not None:
            archive_file = os.path.join(results_dir, 'archive_{}_{}'.format(seed, i))

            if config['robot'].get('per_module_stiffness', False):
                archive.write_3d_map(archive_file + '_3d.csv')
                archive.heatmap_3d(archive_file + '_3d.pdf',
                                   config['robot']['modules_conf']['stiff_table'],
                                   robot.MIN_NUM_MODULES,
                                   config['robot']['max_num_modules'])
                archive.write_best_3d(best_folder, seed, i)
            else:
                archive.write_map(archive_file + '.csv')
                archive.heatmap(archive_file + '.pdf',
                                config['robot']['modules_conf']['stiff_table'],
                                robot.MIN_NUM_MODULES,
                                config['robot']['max_num_modules'])
                archive.write_best(best_folder, seed, i)

            archive.track_best(trajectories_dir, seed, i)

        print('\nDone!')

        end_time = int(time.time() - start_time)
        # record how much time it took for current experiment
        elap_time = '{:02d}:{:02d}:{:02d}'.format(end_time // 3600,
                                                  (end_time % 3600 // 60),
                                                  end_time % 60)
        print('Total computation time: {}'.format(elap_time))
        with open(os.path.join(results_dir, 'elapsed_time_sim_{}.txt'.format(i)), 'w') as out_file:
            out_file.write(elap_time)

        # update experiments common history
        store_history(history, history_file)

        # plot fitness evolution diagram
        fitness_evolution.plot(evo_filename)

        # generate trajectories files
        trajec_file = os.path.join(trajectories_dir,
                                   'robot_trajectories_{}.pdf'.format(i))
        visualize_trajectory.from_folder(trajectories_dir, trajec_file, i, show_act=True)


def gen_robot(create, simulation_path, tracker_path, noise_type=0, noise_level=1.0,
              num_faces=1, max_num_modules=10, mutation_config=None,
              modules_conf=None, robot_tests=3, per_module_stiffness=False, sim_seed=42):
    """ Support function for generating DEAP based individuals, that are robot encodings.

    :param create:
    :param simulation_path:
    :param tracker_path:
    :param noise_type:
    :param noise_level:
    :param num_faces:
    :param max_num_modules:
    :param mutation_config:
    :param modules_conf:
    :param robot_tests:
    :param per_module_stiffness:
    :param sim_seed:
    :return:
    """
    return create(simulation_path, tracker_path, noise_type, noise_level,
                  num_faces, max_num_modules, mutation_config, modules_conf,
                  robot_tests, per_module_stiffness, sim_seed)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Script for simulating via EA'
                                                 'the evolution of a modular soft robot')
    parser.add_argument('settings', metavar='settings', type=str, nargs='?',
                        default='settings.json', help='file name of the configuration file' +
                        ' containing the parameters for this simulation.' +
                        ' By default it looks for the settings.json file.')
    parser.add_argument('--use-checkpoint', dest='use_checkpoint', action='store_const',
                        const=True, help='Select whether to run the experiment ' +
                                         'from previous checkpoints (if exist).')
    parser.add_argument('--clear-history', dest='clear_history', action='store_const',
                        const=True, help='Select whether delete previous history to have a fresh start.'
                        ' This option is disabled by default.')
    args = parser.parse_args()

    # load external configuration for this run
    with open(str(args.settings)) as conf_file:
        settings = json.load(conf_file)

    # prepare the structure of the EA algorithm
    toolbox = base.Toolbox()
    toolbox.register('robot', gen_robot, creator.Robot,
                     simulation_path=settings['simulation_path'],
                     tracker_path=settings['tracker_path'],
                     noise_type=settings.get('noise_type', 1),
                     noise_level=settings.get('noise_level', 0.035),
                     **settings['robot'])
    toolbox.register('population', tools.initRepeat, list, toolbox.robot)

    toolbox.register('evaluate', robot.evaluate_robot)
    toolbox.register('mate', robot.crossover_robots)

    # distinguish between 2D and 3D maps (multi-stiffness experiments)
    if settings['robot'].get('per_module_stiffness', False):
        toolbox.register('mutate', robot.mutate_robot_per_module)
    else:
        toolbox.register('mutate', robot.mutate_robot)

    toolbox.register('selectBest', tools.selBest)
    toolbox.register('select', tools.selRoulette)
    toolbox.register('fill', tools.selRandom)

    pool = multiprocessing.Pool()
    toolbox.register('map', pool.map)

    # execute the evolutionary simulation
    main(settings, toolbox, args.use_checkpoint, args.clear_history)
    pool.close()
